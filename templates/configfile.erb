# THIS FILE IS MANAGED BY PUPPET.
# ANY MODIFICATIONS WILL BE OVERWRITTEN!!!

# The default compiled in settings are fairly paranoid.
# Please see vsftpd.conf.5 for all compiled in defaults.

# READ THIS: This file is NOT an exhaustive list of vsftpd options.
# Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's
# capabilities.
<% if @one_process_model != nil -%>

# If you have a Linux 2.4 kernel, it is possible to use a different security
# model which only uses one process per connection. It # is a less pure
# security model, but gains you performance. You really don't want to enable
# this unless you know what you are doing, and your site supports
# huge numbers of simultaneously connected users.
#
# Default: NO
#
one_process_model=<%= scope.call_function('vsftpd::bool2vsftpd', [@one_process_model]) %>
<% end -%>
<% if @run_as_launching_user != nil -%>

# Set to YES if you want vsftpd to run as the user which launched vsftpd. This is useful
# where root access is not available. MASSIVE WARNING! Do NOT enable this option
# unless you totally know what you are doing, as naive use of this option
# can create massive security problems. Specifically, vsftpd does not / cannot use
# chroot technology to restrict file access when this option is set
# (even if launched by root). A poor substitute could be to use a deny_file
# setting such as {/*,*..*}, but the reliability of this cannot compare to chroot,
# and should not be relied on. If using this option, many restrictions on
# other options apply. For example, options requiring privilege such as
# non-anonymous logins, upload ownership changing, connecting from port 20 and
# listen ports less than 1024 are not expected to work. Other options may be impacted.
#
# Default: NO
#
run_as_launching_user=<%= scope.call_function('vsftpd::bool2vsftpd', [@run_as_launching_user]) %>
<% end -%>
<% if @virtual_use_local_privs != nil -%>

# If enabled, virtual users will use the same privileges as local users.
# By default, virtual users will use the same privileges as anonymous users,
# which tends to be more restrictive (especially in terms of write access).
#
# Default: NO
#
virtual_use_local_privs=<%= scope.call_function('vsftpd::bool2vsftpd', [@virtual_use_local_privs]) %>
<% end -%>
<% if @session_support != nil -%>

# This controls whether vsftpd attempts to maintain sessions for logins.
# If vsftpd is maintaining sessions, it will try and update utmp and wtmp.
# It will also open a pam_session if using PAM to authenticate, and only close
# this upon logout. You may wish to disable this if you do not need
# session logging, and you wish to give vsftpd more opportunity to run with
# less processes and / or less privilege.
# NOTE - utmp and wtmp support is only provided with PAM enabled builds.
#
# Default: NO
#
session_support=<%= scope.call_function('vsftpd::bool2vsftpd', [@session_support]) %>
<% end -%>
<% if @setproctitle_enable != nil -%>

# If enabled, vsftpd will try and show session status information in the
# system process listing. In other words, the reported name of the
# process will change to reflect what a vsftpd session is doing
# (idle, downloading etc). You probably want to leave this off
# for security purposes.
#
# Default: NO
#
setproctitle_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@setproctitle_enable]) %>
<% end -%>
<% if @background != nil -%>

# When enabled, and vsftpd is started in "listen" mode, vsftpd will background
# the listener process. i.e. control will immediately be returned to the shell
# which launched vsftpd.
#
# Default: NO
#
background=<%= scope.call_function('vsftpd::bool2vsftpd', [@background]) %>
<% end -%>
<% if @address_space_limit != nil -%>

# Set the amount of memory vsftpd can use (in bytes). This limit exists so
# that attackers cannot exploit any potential bugs in the server that might
# result in vsftpd allocating huge amounts of memory that would affect the
# host system negatively, e.g. causing thrashing or killing random processes
# due to Linux's OOM system. If the value is configured too low, vsftpd will
# fail with "out of memory" errors during normal operations. Oftentimes, this
# occurs inside of the PAM stack on systems that have many memory
# intensive PAM modules enabled.
#
# Default: 104857600 (100MB)
#
address_space_limit=<%= @address_space_limit %>
<% end -%>
<% if @trans_chunk_size != nil -%>

# You probably don't want to change this, but try setting it to something
# like 8192 for a much smoother bandwidth limiter.
#
# Default: 0 (let vsftpd pick a sensible setting)
#
trans_chunk_size=<%= @trans_chunk_size %>
<% end -%>
<% if @check_shell != nil -%>

# Note! This option only has an effect for non-PAM builds of vsftpd. If disabled, vsftpd will
# not check /etc/shells for a valid user shell for local logins.
#
# Default: YES
#
check_shell=<%= scope.call_function('vsftpd::bool2vsftpd', [@check_shell]) %>
<% end -%>
<% if @force_dot_files != nil -%>

# If activated, files and directories starting with . will be shown in directory
# listings even if the "a" flag was not used by the client. This override
# excludes the "." and ".." entries.
#
# Default: NO
#
force_dot_files=<%= scope.call_function('vsftpd::bool2vsftpd', [@force_dot_files]) %>
<% end -%>
<% if @ls_recurse_enable != nil -%>

# When enabled, this setting will allow the use of "ls -R". This is a minor
# security risk, because a ls -R at the top level of a large site may
# consume a lot of resources.
#
# Default: NO
#
ls_recurse_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@ls_recurse_enable]) %>
<% end -%>
<% if @mdtm_write != nil -%>

# When enabled, this setting will allow MDTM to set file modification
# times (subject to the usual access checks).
#
# Default: YES
#
mdtm_write=<%= scope.call_function('vsftpd::bool2vsftpd', [@mdtm_write]) %>
<% end -%>
<% if @deny_email_enable != nil -%>

# If activated, you may provide a list of anonymous password e-mail responses
# which cause login to be denied. By default, the file containing this list
# is /etc/vsftpd.banned_emails, but you may override this with the banned_email_file setting.
#
# Default: NO
#
deny_email_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@deny_email_enable]) %>
<% end -%>
<% if @secure_email_list_enable != nil -%>

# Set to YES if you want only a specified list of e-mail passwords for
# anonymous logins to be accepted. This is useful as a low-hassle
# way of restricting access to low-security content without needing
# virtual users. When enabled, anonymous logins are prevented unless
# the password provided is listed in the file specified by the
# email_password_file setting. The file format is one password per
# line, no extra whitespace. The default filename is /etc/vsftpd.email_passwords.
#
# Default: NO
#
secure_email_list_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@secure_email_list_enable]) %>
<% end -%>
<% if @dirlist_enable != nil -%>

# If set to NO, all directory list commands will give permission denied.
#
# Default: YES
#
dirlist_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@dirlist_enable]) %>
<% end -%>
<% if @local_enable != nil -%>

# Uncomment this to allow local users to log in.
# When SELinux is enforcing check for SE bool ftp_home_dir
#
local_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@local_enable]) %>
<% end -%>
<% if @chmod_enable != nil -%>

# When enabled, allows use of the SITE CHMOD command. NOTE! This only applies to local
# users. Anonymous users never get to use SITE CHMOD.
#
# Default: YES
#
chmod_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@chmod_enable]) %>
<% end -%>
<% if @download_enable != nil -%>

# If set to "NO" only uploads are possible
#
download_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@download_enable]) %>
<% end -%>
<% if @write_enable != nil -%>

# This controls whether any FTP commands which change the filesystem are allowed or not.
# These commands are: STOR, DELE, RNFR, RNTO, MKD, RMD, APPE and SITE.
#
# Default: NO
#
write_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@write_enable]) %>
<% end -%>
<% if @max_login_fails != nil -%>

# After this many login failures, the session is killed.
#
# Default: 3
#
max_login_fails=<%= @max_login_fails %>
<% end -%>
<% if @delay_failed_login != nil -%>

# The number of seconds to pause prior to reporting a failed login.
#
# Default: 1
#
delay_failed_login=<%= @delay_failed_login %>
<% end -%>
<% if @delay_successful_login != nil -%>

# The number of seconds to pause prior to allowing a successful login.
#
# Default: 0
#
delay_successful_login=<%= @delay_successful_login %>
<% end -%>
<% if @port_enable != nil -%>

# Set to NO if you want to disallow the PORT method of obtaining a data connection.
#
# Default: YES
#
port_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@port_enable]) %>
<% end -%>
<% if @port_promiscuous != nil -%>

# Set to YES if you want to disable the PORT security check that ensures
# that outgoing data connections can only connect to the client. Only enable
# if you know what you are doing!
#
# Default: NO
#
port_promiscuous=<%= scope.call_function('vsftpd::bool2vsftpd', [@port_promiscuous]) %>
<% end -%>
<% if @local_umask != nil -%>

# Default umask for local users is 077. You may wish to change this to 022,
# if your users expect that (022 is used by most other ftpd's)
#
local_umask=<%= @local_umask %>
<% end -%>
<% if @local_max_rate != nil -%>

# The maximum data transfer rate permitted, in bytes per second, for local authenticated users.
# Default: 0 (unlimited)
#
local_max_rate=<%= @local_max_rate %>
<% end -%>
<% if @anonymous_enable != nil -%>

# Allow anonymous FTP? (Beware - allowed by default if you comment this out).
#
anonymous_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@anonymous_enable]) %>
<% end -%>
<% if @anon_mkdir_write_enable != nil -%>

# If set to YES, anonymous users will be permitted to create new directories under certain conditions.
# For this to work, the option write_enable must be activated, and the anonymous ftp user must have
# write permission on the parent directory.
#
anon_mkdir_write_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@anon_mkdir_write_enable]) %>
<% end -%>
<% if @anon_other_write_enable != nil -%>

# If set to YES, anonymous users will be permitted to perform write operations other than upload and
# create directory, such as deletion and renaming. This is generally not recommended but included for completeness.
#
anon_other_write_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@anon_other_write_enable]) %>
<% end -%>
<% if @anon_upload_enable != nil -%>

# If set to YES, anonymous users will be permitted to upload files under certain conditions. For this to work,
# the option write_enable must be activated, and the anonymous ftp user must have write permission on desired
# upload locations. This setting is also required for virtual users to upload; by default virtual users are
# treated with anonymous (i.e. maximally restricted) privilege.
#
anon_upload_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@anon_upload_enable]) %>
<% end -%>
<% if @anon_world_readable_only != nil -%>

# when enabled, anonymous users will only be allowed to download files which are world readable.
# This is recognising that the ftp user may own files, especially in the presence of upload.
# Defaults: YES
#
anon_world_readable_only=<%= scope.call_function('vsftpd::bool2vsftpd', [@anon_world_readable_only]) %>
<% end -%>
<% if @anon_umask != nil -%>

# The value that the umask for file creation is set to for anonymous users. NOTE! If you want to specify
# octal values, remember the "0" prefix otherwise the value will be treated as a base 10 integer!
#
# Default: 077
#
anon_umask=<%= @anon_umask %>
<% end -%>
<% if @anon_root != nil -%>

# This option represents a directory which vsftpd will try to change into after an anonymous login. Failure is silently ignored.
#
# Default: (none)
#
anon_root=<%= @anon_root %>
<% end -%>
<% if @anon_max_rate != nil -%>

# The maximum data transfer rate permitted, in bytes per second, for anonymous clients.
#
# Default: 0 (unlimited)
#
anon_max_rate=<%= @anon_max_rate %>
<% end -%>
<% if @no_anon_password != nil -%>

# When enabled, this prevents vsftpd from asking for an anonymous password - the
# anonymous user will log straight in.
#
# Default: NO
#
no_anon_password=<%= scope.call_function('vsftpd::bool2vsftpd', [@no_anon_password]) %>
<% end -%>
<% if @ftp_username != nil -%>

# This is the name of the user we use for handling anonymous FTP.
# The home directory of this user is the root of the anonymous FTP area.
#
# Default: ftp
#
ftp_username=<%= @ftp_username %>
<% end -%>
<% if @guest_enable != nil -%>

# If enabled, all non-anonymous logins are classed as "guest" logins.
# A guest login is remapped to the user specified in the
# guest_username setting.
#
# Default: NO
#
guest_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@guest_enable]) %>
<% end -%>
<% if @guest_username != nil -%>

# See the boolean setting guest_enable for a description of what constitutes a
# guest login. This setting is the real username which guest users are mapped to.
#
# Default: ftp
guest_username=<%= @guest_username %>
<% end -%>
<% if @dirmessage_enable != nil -%>

# If enabled, users of the FTP server can be shown messages when they
# first enter a new directory. By default, a directory is scanned for
# the file .message, but that may be overridden with the configuration
# setting message_file.
#
# Default: NO (but the sample config file enables it)
#
dirmessage_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@dirmessage_enable]) %>
<% end -%>
<% if @connect_from_port_20 != nil -%>

# This controls whether PORT style data connections use port 20 (ftp-data) on
# the server machine. For security reasons, some clients may insist that this is
# the case. Conversely, disabling this option enables vsftpd to run with slightly less privilege.
#
# Default: NO (but the sample config file enables it)
#
connect_from_port_20=<%= scope.call_function('vsftpd::bool2vsftpd', [@connect_from_port_20]) %>
<% end -%>
<% if @chown_uploads != nil -%>

# If enabled, all anonymously uploaded files will have the ownership changed to the
# user specified in the setting chown_username. This is useful from an administrative,
# and perhaps security, standpoint.
#
# Default: NO
#
chown_uploads=<%= scope.call_function('vsftpd::bool2vsftpd', [@chown_uploads]) %>
<% end -%>
<% if @chown_username != nil -%>

# the username to chown to. Use only together with "chown_uploads"
#
chown_username=<%= @chown_username %>
<% end -%>
<% if @chown_upload_mode != nil -%>

# The file mode to force for chown()ed anonymous uploads. (Added in v2.0.6).
#
chown_upload_mode=<%= @chown_upload_mode %>
<% end -%>
<% if @delete_failed_uploads != nil -%>

# if true, any failed uploaded files are deleted.
#
# Default: NO
#
delete_failed_uploads=<%= scope.call_function('vsftpd::bool2vsftpd', [@delete_failed_uploads]) %>
<% end -%>
<% if @lock_upload_files != nil -%>

# When enabled, all uploads proceed with a write lock on the upload file.
# All downloads proceed with a shared read lock on the download file.
# WARNING! Before enabling this, be aware that malicious readers
# could starve a writer wanting to e.g. append a file.
#
# Default: YES
#
lock_upload_files=<%= scope.call_function('vsftpd::bool2vsftpd', [@lock_upload_files]) %>
<% end -%>
<% if @idle_session_timeout != nil -%>

# You may change the default value for timing out an idle session.
#
idle_session_timeout=<%= @idle_session_timeout %>
<% end -%>
<% if @data_connection_timeout != nil -%>

# You may change the default value for timing out a data connection.
#
data_connection_timeout=<%= @data_connection_timeout %>
<% end -%>
<% if @nopriv_user != nil -%>

# It is recommended that you define on your system a unique user which the
# ftp server can use as a totally isolated and unprivileged user.
nopriv_user=<%= @nopriv_user %>
<% end -%>
<% if @async_abor_enable != nil -%>

# Enable this and the server will recognise asynchronous ABOR requests. Not
# recommended for security (the code is non-trivial). Not enabling it,
# however, may confuse older FTP clients.
#
async_abor_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@async_abor_enable]) %>
<% end -%>
<% if @ascii_download_enable != nil -%>

# By default the server will pretend to allow ASCII mode but in fact ignore
# the request. Turn on the below options to have the server actually do ASCII
# mangling on files when in ASCII mode.
# Beware that on some FTP servers, ASCII support allows a denial of service
# attack (DoS) via the command "SIZE /big/file" in ASCII mode. vsftpd
# predicted this attack and has always been safe, reporting the size of the
# raw file.
# ASCII mangling is a horrible feature of the protocol.
#
ascii_download_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@ascii_download_enable]) %>
<% end -%>

<% if @ascii_upload_enable != nil -%>
#
ascii_upload_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@ascii_upload_enable]) %>
<% end -%>
<% if @ftpd_banner != nil -%>

# You may fully customise the login banner string:
# This string option allows you to override the greeting banner displayed by vsftpd when a connection first comes in.
#
# Default: (none - default vsftpd banner is displayed)
#
ftpd_banner=<%= @ftpd_banner %>
<% end -%>
<% if @banner_file != nil -%>

# This option is the name of a file containing text to display when someone connects
# to the server. If set, it overrides the banner string provided by the ftpd_banner option.
#
#Default: (none)
#
banner_file=<%= @banner_file %>
<% end -%>
<% if @file_open_mode != nil -%>

# The permissions with which uploaded files are created. Umasks are applied on top of this value. You may wish to change to 0777
# if you want file to be executable.
#
# Default: 0666
#
file_open_mode=<%= @file_open_mode %>
<% end -%>
<% if @ftp_data_port != nil -%>

# The port from which PORT style connections originate (as long as the poorly named connect_from_port_20 is enabled)
#
ftp_data_port=<%= @ftp_data_port %>
<% end -%>
<% if @listen != nil -%>

# When "listen" directive is enabled, vsftpd runs in standalone mode and
# listens on IPv4 sockets. This directive cannot be used in conjunction
# with the listen_ipv6 directive.
#
listen=<%= scope.call_function('vsftpd::bool2vsftpd', [@listen]) %>
<% end -%>
<% if @listen_ipv6 != nil -%>

# This directive enables listening on IPv6 sockets. By default, listening
# on the IPv6 "any" address (::) will accept connections from both IPv6
# and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6
# sockets. If you want that (perhaps because you want to listen on specific
# addresses) then you must run two copies of vsftpd with two configuration
# files.
# Make sure, that one of the listen options is commented !!
#
listen_ipv6=<%= scope.call_function('vsftpd::bool2vsftpd', [@listen_ipv6]) %>
<% end -%>
<% if @listen_port != nil -%>

# this option changes the listen port of the vsftpd service.
#
listen_port=<%= @listen_port %>
<% end -%>
<% if @pam_service_name != nil -%>

#
pam_service_name=<%= @pam_service_name %>
<% end -%>
<% if @userlist_deny != nil -%>

# This option is examined if userlist_enable is activated. If you set this
# setting to NO, then users will be denied login unless they are explicitly
# listed in the file specified by userlist_file. When login is denied,
# the denial is issued before the user is asked for a password.
#
# Default: YES
#
userlist_deny=<%= scope.call_function('vsftpd::bool2vsftpd', [@userlist_deny]) %>
<% end -%>
<% if @userlist_enable != nil -%>

# If enabled, vsftpd will load a list of usernames, from the filename given
# by userlist_file. If a user tries to log in using a name in this file,
# they will be denied before they are asked for a password. This may be
# useful in preventing cleartext passwords being transmitted.
# See also userlist_deny.
#
# Default: NO
#
userlist_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@userlist_enable]) %>
<% end -%>
<% if @userlist_file != nil -%>

# path to the user list file. depending if userlist_deny is set to "YES" or "NO"
# it's the path to the whitelist or blacklist file
#
userlist_file=<%= @userlist_file %>
<% end -%>
<% if @user_config_dir != nil -%>

# This powerful option allows the override of any config option specified in the manual page,
# on a per-user basis. Usage is simple, and is best illustrated with an example. If you set
# user_config_dir to be /etc/vsftpd_user_conf and then log on as the user "chris", then vsftpd
# will apply the settings in the file /etc/vsftpd_user_conf/chris for the duration of the
# session. The format of this file is as detailed in this manual page! PLEASE NOTE that not all
# settings are effective on a per-user basis. For example, many settings only prior to the
# user's session being started. Examples of settings which will not affect any behviour on a
# per-user basis include listen_address, banner_file, max_per_ip, max_clients, xferlog_file, etc.
#
# Default: (none)
#
user_config_dir=<%= @user_config_dir %>
<% end -%>
<% if @tcp_wrappers != nil -%>

# If enabled, and vsftpd was compiled with tcp_wrappers support, incoming connections will be fed
# through tcp_wrappers access control. Furthermore, there is a mechanism for per-IP based configuration.
# If tcp_wrappers sets the VSFTPD_LOAD_CONF environment variable, then the vsftpd session will
# try and load the vsftpd configuration file specified in this variable.
#
# Default: NO
#
tcp_wrappers=<%= scope.call_function('vsftpd::bool2vsftpd', [@tcp_wrappers]) %>
<% end -%>
<% if @use_localtime != nil -%>

# If enabled, vsftpd will display directory listings with the time in your
# local time zone. The default is to display GMT. Note that this setting
# will NOT affect the times returned by the MDTM FTP command in this version
# of the daemon. This behavior deviates from the upstream version, which violated
# RFC3659 and subsequently caused problems with popular FTP clients.
#
# Default: NO
#
use_localtime=<%= scope.call_function('vsftpd::bool2vsftpd', [@use_localtime]) %>
<% end -%>
<% if @use_sendfile != nil -%>

# An internal setting used for testing the relative benefit of using the
# sendfile() system call on your platform.
#
# Default: YES
#
use_sendfile=<%= scope.call_function('vsftpd::bool2vsftpd', [@use_sendfile]) %>
<% end -%>
<% if @secure_chroot_dir != nil -%>

# This option should be the name of a directory which is empty. Also, the
# directory should not be writable by the ftp user. This directory is used
# as a secure chroot() jail at times vsftpd does not require filesystem
# access.
#
secure_chroot_dir=<%= @secure_chroot_dir %>
<% end -%>
<% if @chroot_local_user != nil -%>

# If set to YES, local users will be (by default) placed in a chroot() jail in
# their home directory after login. Warning: This option has security
# implications, especially if the users have upload permission, or shell access.
# Only enable if you know what you are doing. Note that these security implications
# are not vsftpd specific. They apply to all FTP daemons which offer to put
# local users in chroot() jails.
#
# Default: NO
#
chroot_local_user=<%= scope.call_function('vsftpd::bool2vsftpd', [@chroot_local_user]) %>
<% end -%>
<% if @passwd_chroot_enable != nil -%>

# If enabled, along with chroot_local_user, then a chroot() jail location
# may be specified on a per-user basis. Each user's jail is derived
# from their home directory string in /etc/passwd. The occurrence of /./ in
# the home directory string denotes that the jail is at that
# particular location in the path.
#
# Default: NO
#
passwd_chroot_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@passwd_chroot_enable]) %>
<% end -%>
<% if @chroot_list_enable != nil -%>

# if activated, you may provide a list of local users who are placed in a chroot() jail
# in their home directory upon login. The meaning is slightly different if chroot_local
# _user is set to YES. In this case, the list becomes a list of users which are NOT to
# be placed in a chroot() jail. By default, the file containing this list is
# /etc/vsftpd/chroot_list, but you may override this with chroot_list_file setting
#
chroot_list_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@chroot_list_enable]) %>
<% end -%>
<% if @chroot_list_file != nil -%>

# The option is the name of a file containing a list of local users which will be placed
# in a chroot() jail in their home directory. This option is only relevant if the option
# chroot_list_enable is enabled. If the option chroot_local_user is enabled, then the list
# file becomes a list of users to NOT place in a chroot() jail.
#
# Default: /etc/vsftpd/vsftpd.chroot_list
#
chroot_list_file=<%= @chroot_list_file %>
<% end -%>
<% if @allow_writeable_chroot != nil -%>

#
allow_writeable_chroot=<%= scope.call_function('vsftpd::bool2vsftpd', [@allow_writeable_chroot]) %>
<% end -%>
<% if @allow_root_squashed_chroot != nil -%>

# If set to YES, chroot is called with non-root credentials. This enabled chroot on squashed nfs. This option is applied only if
# chroot is performed, otherwise ignored.
#
# Default: NO
#
allow_root_squashed_chroot=<%= scope.call_function('vsftpd::bool2vsftpd', [@allow_root_squashed_chroot]) %>
<% end -%>
<% if @cmds_allowed != nil -%>

# This option specifies a comma seperated list of allowed FTP commands (post login, USER, PASS, and QUIT
# and others are always allowed pre-login). Other commands are rejected. This is a powerful method of
# really locking down a FTP server. Example: cmds_allowed=PASV,RETR, QUIT
#
# Default: (none)
#
cmds_allowed=<%- @cmds_allowed.each_with_index do |cmd, index| -%>
<%- if index == 0 -%>
<%= cmd -%>
<%- else -%>
,<%= cmd -%>
<%- end -%>
<%- end -%>
<%- end -%>
<% if @cmds_denied != nil -%>

# This options specifies a comma seperated list of denied FTP commands (post login, USER, PASS, QUIT and others are always allowed pre-login).
# If a command appears on both this and cmds_allowed then the denial takes precedence.
#
cmds_denied=<%- @cmds_denied.each_with_index do |cmd, index| -%>
<%- if index == 0 -%>
<%= cmd -%>
<%- else -%>
,<%= cmd -%>
<%- end -%>
<%- end -%>
<% end -%>
<% if @deny_file != nil -%>

# This option can be used to set a pattern for filenames (and directory names etc.)
# which should not be accessible in any way.
# The affected items are not hidden, but any attempt to do anything to
# them (download, change into directory, affect something within
# directory etc.) will be denied.
# This option is very simple, and should not be used for serious access
# control - the filesystem's permissions should be used in preference.
# However, this option may be useful in certain virtual user setups.
# In particular aware that if a filename is accessible by a variety of
# names (perhaps due to symbolic links or hard links),
# then care must be taken to deny access to all the names.
# Access will be denied to items if their name contains the string
# given by hide_file, or if they match the regular expression specified
# by hide_file. Note that vsftpd's regular expression matching code is
# a simple implementation which is a subset of full regular expression
# functionality. Because of this, you will need to carefully and
# exhaustively test any application of this option. And you are
# recommended to use filesystem permissions for any important security
# policies due to their greater reliability. Supported regex syntax is
# any number of *, ? and unnested {,} operators. Regex matching is only
# supported on the last component of a path, e.g. a/b/? is supported
# but a/?/c is not. Example: deny_file={*.mp3,*.mov,.private}

Default: (none)
#
deny_file={<%- @deny_file.each_with_index do |match, index| -%>
<%- if index == 0 -%>
<%= match -%>
<%- else -%>
,<%= match -%>
<%- end -%>
<%- end -%>
}
<% end -%>
<% if @hide_file != nil -%>

# This option can be used to set a pattern for filenames (and directory names etc.)
# which should be hidden from directory listings. Despite being hidden, the files /
# directories etc. are fully accessible to clients who know what names to actually use.
# Items will be hidden if their names contain the string given by hide_file, or if they
# match the regular expression specified by hide_file. Note that vsftpd's regular
# expression matching code is a simple implementation which is a subset of full regular
# expression functionality. See deny_file for details of exactly what regex syntax is
# supported. Example: hide_file={*.mp3,.hidden,hide*,h?}
#
# Default: (none)
#
hide_file={<%- @hide_file.each_with_index do |match, index| -%>
<%- if index == 0 -%>
<%= match -%>
<%- else -%>
,<%= match -%>
<%- end -%>
<%- end -%>
}
<% end -%>
<% if @hide_ids != nil -%>

# If enabled, all user and group information in directory listings will be displayed as "ftp".
#
# Default: NO
#
hide_ids=<%= scope.call_function('vsftpd::bool2vsftpd', [@hide_ids]) %>
<% end -%>
<% if @text_userdb_names != nil -%>

# By default, numeric IDs are shown in the user and group fields of directory
# listings. You can get textual names by enabling this parameter. It is off by
# default for performance reasons.
#
# Default: NO
#
text_userdb_names=<%= scope.call_function('vsftpd::bool2vsftpd', [@text_userdb_names]) %>
<% end -%>
<% if @tilde_user_enable != nil -%>

# If enabled, vsftpd will try and resolve pathnames such as ~chris/pics,
# i.e. a tilde followed by a username. Note that vsftpd will always resolve
# the pathnames ~ and ~/something (in this case the ~ resolves to the
# initial login directory). Note that ~user paths will only resolve if the
# file /etc/passwd may be found within the _current_ chroot() jail.
#
# Default: NO
#
tilde_user_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@tilde_user_enable]) %>
<% end -%>
<% if @syslog_enable != nil -%>

# If enabled, then any log output which would have gone to /var/log/vsftpd.log goes to
# the system log instead. Logging is done under the FTPD facility.
#
# Default: NO
#
syslog_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@syslog_enable]) %>
<% end -%>
<% if @dual_log_enable != nil -%>

# If enabled, two log files are generated in parallel, going by
# default to /var/log/xferlog and /var/log/vsftpd.log. The former
# is a wu-ftpd style transfer log, parseable by standard tools. The
# latter is vsftpd's own style log.
#
# Default: NO
#
dual_log_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@dual_log_enable]) %>
<% end -%>
<% if @log_ftp_protocol != nil -%>

# When enabled, all FTP requests and responses are logged,
# providing the option xferlog_std_format is not enabled.
# Useful for debugging.
#
# Default: NO
#
log_ftp_protocol=<%= scope.call_function('vsftpd::bool2vsftpd', [@log_ftp_protocol]) %>
<% end -%>
<% if @no_log_lock != nil -%>

# When enabled, this prevents vsftpd from taking a file
# lock when writing to log files. This option should generally
# not be enabled. It exists to workaround operating system bugs
# such as the Solaris / Veritas filesystem combination which
# has been # observed to sometimes exhibit hangs trying to
# lock log files.
#
# Default: NO
#
no_log_lock=<%= scope.call_function('vsftpd::bool2vsftpd', [@no_log_lock]) %>
<% end -%>
<% if @xferlog_enable != nil -%>

# Activate logging of uploads/downloads.
#
xferlog_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@xferlog_enable]) %>
<% end -%>
<% if @xferlog_file != nil -%>

# Activate logging of uploads/downloads.
# You may override where the log file goes if you like. The default is /var/log/xferlog
# If you want, you can have your log file in standard ftpd xferlog format.
#
xferlog_file=<%= @xferlog_file %>
<% end -%>
<% if @xferlog_std_format != nil -%>

#
xferlog_std_format=<%= scope.call_function('vsftpd::bool2vsftpd', [@xferlog_std_format]) %>
<% end -%>
<% if @max_clients != nil -%>

# If vsftpd is in standalone mode, this is the maximum number of clients which may be connected.
# Any additional clients connecting will get an error message.
#
# Default: 0 (unlimited)
#
max_clients=<%= @max_clients %>
<% end -%>
<% if @max_per_ip != nil -%>

# If vsftpd is in standalone mode, this is the maximum number of clients which may be connected from
# the same source internet address. A client will get an error message if they go over this limit.
#
# Default: 0 (unlimited)
#
max_per_ip=<%= @max_per_ip %>
<% end -%>
<% if @pasv_enable != nil -%>

#
pasv_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@pasv_enable]) %>
<% end -%>
<% if @pasv_addr_resolve != nil -%>

# Set to YES if you want to use a hostname (as opposed to IP address) in
# the pasv_address option.
#
# Default: NO
#
pasv_addr_resolve=<%= scope.call_function('vsftpd::bool2vsftpd', [@pasv_addr_resolve]) %>
<% end -%>
<% if @pasv_address != nil -%>

#
pasv_address=<%= @pasv_address %>
<% end -%>
<% if @pasv_promiscuous != nil -%>

# Set to YES if you want to disable the PASV security check that ensures
# the data connection originates from the same IP address as the control
# connection. Only enable if you know what you are doing! The only
# legitimate use for this is in some form of secure tunnelling scheme,
# or perhaps to facilitate FXP support.
#
# Default: NO
#
pasv_promiscuous=<%= scope.call_function('vsftpd::bool2vsftpd', [@pasv_promiscuous]) %>
<% end -%>
<% if @pasv_min_port != nil -%>

# The minimum port to allocate for PASV style data connections. Can be used to specify a narrow port range to assist firewalling.
#
# Default: 0 (use any port)
pasv_min_port=<%= @pasv_min_port %>
<% end -%>
<% if @pasv_max_port != nil -%>

# The maximum port to allocate for PASV style data connections. Can be used
# to specify a narrow port range to assist firewalling.
#
# Default: 0 (use any port)
#
pasv_max_port=<%= @pasv_max_port %>
<% end -%>
<% if @accept_timeout != nil -%>

# The timeout, in seconds, for a remote client to establish connection with a PASV style data connection.
#
# Default: 60
#
accept_timeout=<%= @accept_timeout %>
<% end -%>
<% if @connect_timeout != nil -%>

# The timeout, in seconds, for a remote client to respond to our PORT style data connection.
#
# Default: 60
#
connect_timeout=<%= @connect_timeout %>
<% end -%>
<% if @data_connect_timeout != nil -%>

# The timeout, in seconds, which is roughly the maximum time we permit data transfers to stall
# for with no progress. If the timeout triggers, the remote client is kicked off.
#
# Default: 300
#
data_connect_timeout=<%= @data_connect_timeout %>
<% end -%>
<% if @ssl_enable != nil -%>

#
ssl_enable=<%= scope.call_function('vsftpd::bool2vsftpd', [@ssl_enable]) %>
<% end -%>
<% if @ssl_ciphers != nil -%>

#
ssl_ciphers=<%= @ssl_ciphers %>
<% end -%>
<% if @ssl_sslv2 != nil -%>

#
ssl_sslv2=<%= scope.call_function('vsftpd::bool2vsftpd', [@ssl_sslv2]) %>
<% end -%>
<% if @ssl_sslv3 != nil -%>

#
ssl_sslv3=<%= scope.call_function('vsftpd::bool2vsftpd', [@ssl_sslv3]) %>
<% end -%>
<% if @ssl_tlsv1 != nil -%>

#
ssl_tlsv1=<%= scope.call_function('vsftpd::bool2vsftpd', [@ssl_tlsv1]) %>
<% end -%>
<% if @debug_ssl != nil -%>

# If true, OpenSSL connection diagnostics are dumped to the vsftpd log file. (Added in v2.0.6).
#
debug_ssl=<%= scope.call_function('vsftpd::bool2vsftpd', [@debug_ssl]) %>
<% end -%>
<% if @allow_anon_ssl != nil -%>

#
allow_anon_ssl=<%= scope.call_function('vsftpd::bool2vsftpd', [@allow_anon_ssl]) %>
<% end -%>
<% if @force_anon_data_ssl != nil -%>

# Only applies if ssl_enable is activated. If activated, all anonymous logins are
# forced to use a secure SSL connection in order to send and receive data on
# data connections.
#
# Default: NO
#
force_anon_data_ssl=<%= scope.call_function('vsftpd::bool2vsftpd', [@force_anon_data_ssl]) %>
<% end -%>
<% if @force_anon_logins_ssl != nil -%>

# Only applies if ssl_enable is activated. If activated, all anonymous logins are
# forced to use a secure SSL connection in order to send the password.
#
# Default: NO
#
force_anon_logins_ssl=<%= scope.call_function('vsftpd::bool2vsftpd', [@force_anon_logins_ssl]) %>
<% end -%>
<% if @force_local_data_ssl != nil -%>

#
force_local_data_ssl=<%= scope.call_function('vsftpd::bool2vsftpd', [@force_local_data_ssl]) %>
<% end -%>
<% if @force_local_logins_ssl != nil -%>

#
force_local_logins_ssl=<%= scope.call_function('vsftpd::bool2vsftpd', [@force_local_logins_ssl]) %>
<% end -%>
<% if @implicit_ssl != nil -%>

# If enabled, an SSL handshake is the first thing expect on all connections
# (the FTPS protocol). To support explicit SSL and/or plain text too, a separate
# vsftpd listener process should be run.
#
# Default: NO
#
implicit_ssl=<%= scope.call_function('vsftpd::bool2vsftpd', [@implicit_ssl]) %>
<% end -%>
<% if @require_ssl_reuse != nil -%>

#
require_ssl_reuse=<%= scope.call_function('vsftpd::bool2vsftpd', [@require_ssl_reuse]) %>
<% end -%>
<% if @strict_ssl_read_eof != nil -%>

# If enabled, SSL data uploads are required to terminate via SSL, not an EOF
# on the socket. This option is required to be sure that an attacker did not
# terminate an upload prematurely with a faked TCP FIN. Unfortunately,
# it is not enabled by default because so few clients get it right. (New in v2.0.7).
#
# Default: NO
#
strict_ssl_read_eof=<%= scope.call_function('vsftpd::bool2vsftpd', [@strict_ssl_read_eof]) %>
<% end -%>
<% if @strict_ssl_write_shutdown != nil -%>

# If enabled, SSL data downloads are required to terminate via SSL, not
# an EOF on the socket. This is off by default as I was unable to find a
# single FTP client that does this. It is minor. All it affects is our ability
# to tell whether the client confirmed full receipt of the file. Even
# without this option, the client is able to check the integrity of the download.
# (New in v2.0.7).
#
# Default: NO
#
strict_ssl_write_shutdown=<%= scope.call_function('vsftpd::bool2vsftpd', [@strict_ssl_write_shutdown]) %>
<% end -%>
<% if @require_cert != nil -%>

# If set to yes, all SSL client connections are required to present a
# client certificate. The degree of validation applied to this
# certificate is controlled by validate_cert (Added in v2.0.6).
#
# Default: NO
#
require_cert=<%= scope.call_function('vsftpd::bool2vsftpd', [@require_cert]) %>
<% end -%>
<% if @validate_cert != nil -%>

# If set to yes, all SSL client certificates received must validate OK.
# Self-signed certs do not constitute OK validation. (New in v2.0.6).
#
# Default: NO
#
validate_cert=<%= scope.call_function('vsftpd::bool2vsftpd', [@validate_cert]) %>
<% end -%>
<% if @ssl_request_cert != nil -%>

# If enabled, vsftpd will request (but not necessarily require; see
# require_cert) a certificate on incoming SSL connections. Normally this
# should not cause any trouble at all, but IBM zOS seems to
# have issues. (New in v2.0.7).
#
# Default: YES
#
ssl_request_cert=<%= scope.call_function('vsftpd::bool2vsftpd', [@ssl_request_cert]) %>
<% end -%>
<% if @rsa_cert_file != nil -%>

# This option specifies the location of the RSA certificate to use for SSL
# encrypted connections.
#
rsa_cert_file=<%= @rsa_cert_file %>
<% end -%>
<% if @rsa_private_key_file != nil -%>

# This option specifies the location of the RSA key to use for SSL
# encrypted connections.
#
rsa_private_key_file=<%= @rsa_private_key_file %>
<% end -%>
